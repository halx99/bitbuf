#include <assert.h>
#include <ctype.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <algorithm>
#include <fstream>
#include <functional>
#include <regex>
#include <set>
#include <new>

#define _TEST 0

#if defined( _DEBUG) && _TEST == 1
#include "pa_client_constants.h"
#include "pa_client_messages.h"
#endif

#include "utils/xmldrv.h"
#include "utils/xxfsutility.h"

#define VERSION "1.19.5"

#define _FORMAT_CTL(width,delim) std::setw(width) << std::setfill(delim) << std::setiosflags(std::ios_base::left)
#define _FORMAT_STRING(width,tip,value,delim) _FORMAT_CTL(width, delim) << std::string(tip) + " " << " " << value
#define strfmt(tip,value,delim) _FORMAT_STRING(23, tip, value, delim)

static const char* inc_file_comments = "/* This file is generated by pcode_autog-" VERSION "\n"
"** Copyright(c) Lake.Deal, ALL RIGHTS RESERVED.\n"
"**\n"
"** Purpose: Includes\n"
"**\n"
"*/";

static const char* strucs_file_comments = "/* This file is generated by pcode_autog-" VERSION "\n"
"** Copyright(c) Lake.Deal, ALL RIGHTS RESERVED.\n"
"**\n"
"** Purpose: contains basic structures for protocol\n"
"**\n"
"*/";

static const char* consts_file_comments = "/* This file is generated by pcode_autog-" VERSION "\n"
"** Copyright(c) Lake.Deal, ALL RIGHTS RESERVED.\n"
"**\n"
"** Purpose: contains some constants defininations\n"
"**\n"
"*/";

static const char* messages_file_comments = "/* This file is generated by pcode_autog-" VERSION "\n"
"** Copyright(c) Lake.Deal, ALL RIGHTS RESERVED.\n"
"**\n"
"** Purpose: contains all protocol message definiations and codec function\n"
"**          implementations\n"
"**\n"
"*/";

struct field
{
    std::string name;
    std::string type;
    // std::string specific_value;
    std::string length_specifier;
    std::string present_condition;
    bool varidic;
};

enum {
    MODE_NONE = 0,
    MODE_ENCODE = 1,
    MODE_DECODE = 2,
    MODE_ALL = MODE_ENCODE | MODE_DECODE,


    MODE_LUA_ENC = 16,
    MODE_LUA_DEC = MODE_LUA_ENC << 1,
    MODE_LUA_ALL = MODE_LUA_ENC | MODE_LUA_DEC,
};

struct typeinfo
{
    bool               zlib = false;
    bool               is_header = false;
    std::string        name;
    int                mode; // encode/decode/full
    std::string        command_id;
    std::vector<std::string>  command_id_detail;// 0 symbol 1 value
    std::string        action;
    std::vector<field> fields;
    std::set<std::string> length_fields;
    bool has_field(const std::string& fieldName) {
        for (const auto& f : fields)
        {
            if (f.name == fieldName)
                return true;
        }
        return false;
    }
};

static const int sz = sizeof(field);

struct protocol_info
{
    std::string                       name;
    std::string                       vresion;
    std::string                       author;
    std::string                       release_date;
    std::map<std::string, typeinfo>   struc_tab;
    std::vector<typeinfo>             struc_list;
    std::vector<typeinfo>             messages;
};

bool has_keyword(const std::string& line, const std::string& keyword)
{

    auto offset = std::string::npos;
    if ((offset = line.find(keyword)) == std::string::npos)
        return false;

    if (offset > 0) {
        if (isalpha(line[offset - 1]))
            return false;
    }

    offset = offset + keyword.size();
    if (offset < line.size()) {
        if (!isspace(line[offset]) && line[offset] != '(')
            return false;
    }

    return true;
}

//bool is_number(const std::string& value)
//{
//    for(int i = 0; i < value.length(); ++i)
//    {
//        if( isalpha(value[i]) )
//        {
//            return false;
//        }
//    }
//    return !value.empty();
//}

std::string ident(int deep)
{
    return std::string(deep * 4, ' ');
}

bool is_fixed_array(const field & f)
{
    return f.name.find('[') != std::string::npos;
};

bool is_variable_pointer(const field & f)
{
    return '*' == *f.type.rbegin();
}

bool is_stl_vector(const field & f)
{
    return f.type.find("vector<") != std::string::npos;
}

bool is_single_type_of_field(const field & f)
{
    return !is_fixed_array(f) && !is_variable_pointer(f) && !is_stl_vector(f);
}

bool is_bytestream(const field & f)
{
    return f.type == "char*" ||
        f.type == "unsigned char*" ||
        f.type == "int8_t*" ||
        f.type == "uint8_t*" ||
        ((f.type == "char" ||
            f.type == "unsigned char" ||
            f.type == "int8_t" ||
            f.type == "uint8_t") && is_fixed_array(f));
}

std::string get_fixed_array_size(const field & f)
{
    std::string::size_type begin = f.name.find('[') + 1;
    std::string size_value = f.name.substr(begin, f.name.length() - begin - 1);
    return std::move(size_value);
}

// if is fixed array, then get name except symbol '[]', else return name
std::string get_field_name(const field & f)
{
    if (is_fixed_array(f))
    {
        std::string::size_type pos = f.name.find_first_of('[');
        std::string array_name = f.name.substr(0, pos);
        return std::move(array_name);
    }
    return f.name;
}

bool is_oneb_type(const std::string & type)
{
    return "bool" == type ||
        "char" == type ||
        "int8_t" == type ||
        "uint8_t" == type ||
        "unsigned char" == type;
}

bool is_twob_type(const std::string & type)
{
    return "short" == type ||
        "unsigned short" == type ||
        "int16_t" == type ||
        "uint16_t" == type;
}

bool is_fourb_type(const std::string & type)
{
    return "int" == type ||
        "unsigned int" == type ||
        "int32_t" == type ||
        "uint32_t" == type ||
        "long" == type ||
        "unsigned long" == type;
}

bool is_eightb_type(const std::string & type)
{
    return "double" == type ||
        "long long" == type ||
        "unsigned long long" == type ||
        "int64_t" == type ||
        "uint64_t" == type;
}

bool is_integral_type(const std::string & type)
{
    return "bool" == type ||
        "char" == type ||
        "int8_t" == type ||
        "int16_t" == type ||
        "int32_t" == type ||
        "int64_t" == type ||
        "uint8_t" == type ||
        "uint16_t" == type ||
        "uint24_t" == type ||
        "uint32_t" == type ||
        "uint64_t" == type ||
        "short" == type ||
        "int" == type ||
        "long" == type ||
        "long long" == type ||
        "unsigned char" == type ||
        "unsigned short" == type ||
        "unsigned int" == type ||
        "unsigned long" == type ||
        "unsigned long long" == type ||
        "float" == type ||
        "long float" == type ||
        "double" == type ||
        "long double" == type;
}

std::string parse_item_type(const std::string & stlvec)
{
    int start = stlvec.find_first_of('<');
    int end = stlvec.find_first_of('>', start + 1);

    return stlvec.substr(start + 1, end - start - 1);
}

bool is_basic_type(const std::string & ctype, std::string * suffix = nullptr)
{
    auto type = ctype;
    auto pos = ctype.find_first_of('[');
    if (pos != std::string::npos)
        type.resize(pos);

    if (suffix == nullptr) {

        return type == ("bool") ||
            type == ("char") ||
            type == ("int8_t") ||
            type == ("int16_t") ||
            type == ("int32_t") ||
            type == ("int64_t") ||
            type == ("uint8_t") ||
            type == ("uint16_t") ||
            type == ("uint24_t") ||
            type == ("uint32_t") ||
            type == ("uint64_t") ||
            type == ("short") ||
            type == ("int") ||
            //type == ("long") ||
            type == ("long long") ||
            type == ("unsigned char") ||
            type == ("unsigned short") ||
            type == ("unsigned int") ||
            //type == ("unsigned long") ||
            type == ("unsigned long long") ||
            type == ("float") ||
            type == ("long float") ||
            type == ("double") ||
            type == ("long double");
    }
    else {
        if (type == "bool") {
            *suffix = "bool";
        }
        else if (type == "int8_t" || type == "char")
        {
            *suffix = "i8";
        }
        else if (type == "uint8_t" || type == "unsigned char")
        {
            *suffix = "u8";
        }
        else if (type == "int16_t" || type == "short")
        {
            *suffix = "i16";
        }
        else if (type == "uint16_t" || type == "unsigned short")
        {
            *suffix = "u16";
        }
        else if (type == "int32_t" || type == "int")
        {
            *suffix = "i32";
        }
        else if (type == "uint32_t" || type == "unsigned int")
        {
            *suffix = "u32";
        }
        else if (type == "int64_t" || type == "long long") {
            *suffix = "i64";
        }
        else if (type == "uint64_t" || type == "unsigned long long") {
            *suffix = "u64";
        }
        else if (type == "float") {
            *suffix = "f";
        }
        else if (type == "long float" || type == "double" || type == "long double") {
            *suffix = "lf";
        }
        else if (type == "uint24_t") {
            *suffix = "i24";
        }
        else {
            suffix->clear();
        }
        return !suffix->empty();
    }
}

bool is_fixed_array_type(const std::string & type)
{
    std::size_t pos = type.find_first_of('[');
    return pos != std::string::npos;
}

bool is_string_type(const std::string & type)
{
    return type.find("string") != type.npos;
}

bool is_exists_field_except(const typeinfo & ti, const std::string & target, const std::string & except, std::string & field_type)
{
    if (target == except)
    {
        return false;
    }
    for (auto iter = ti.fields.begin(); iter != ti.fields.end(); ++iter)
    {
        if (target == iter->name)
        {
            field_type = iter->type;
            return true;
        }
    }
    return false;
}

std::string get_array_field_trim_name(const std::string & name)
{
    std::size_t pos = name.find_first_of('[');
    if (name.npos == pos)
    {
        pos = name.find('*');
    }

    if (pos != name.npos)
    {
        return name.substr(0, pos);
    }
    else {
        return name;
    }
}

class pcode_autog
{
private:
    std::string prefix = "pcode_autog_";
public:
    pcode_autog(const char* filename = "protocol.xml")
    {
        this->config.open(filename);
    }

    void load_config(void)
    {
        auto checkdata = config.root().get_child("check_data").get_value("");

        // load base info
        this->pi.name = this->config.root().get_attribute_value("name", "");
        prefix.append(this->pi.name + "_");
        this->pi.vresion = this->config.root().get_attribute_value("version", "");
        this->pi.author = this->config.root().get_attribute_value("author", "");
        this->pi.release_date = this->config.root().get_attribute_value("release_date", "");

        this->includes_decl.open(prefix + "includes.h");
        this->constants_decl.open(prefix + "constants.h");
        this->structures_decl.open(prefix + "structures.h");
        this->messages_decl.open(prefix + "messages.h");
        this->messages_impl.open(prefix + "messages.cpp");
        this->constants_lua.open(prefix + "constants.lua");

        this->protocol_const_lua.open("protocol_enums.lua");
        this->protocol_enc_lua.open("protocol_enc.lua");
        this->protocol_dec_lua.open("protocol_dec.lua");

        // load base types info, TODO
        this->config.root().get_child("structures").cforeach("structure", std::bind(&pcode_autog::_Load_structure, this, std::placeholders::_1));

        // load messages info
        this->config.root().get_child("messages").cforeach("message", std::bind(&pcode_autog::_Load_message, this, std::placeholders::_1));
    }

    void generate_code(void)
    {
        // generate messages definination code
        _Generate_constants();
        _Generate_constants_lua();
        _Generate_includes();
        _Generate_structures();
        _Generate_messages_decl();
        _Generate_messages_impl();
    }

    void _Load_structure(const xmldrv::element & elem_structure)
    {
        typeinfo struc;
        struc.name = elem_structure.get_attribute_value("name", "");
        elem_structure.cforeach("field", std::bind(&pcode_autog::_Load_field, this, std::placeholders::_1, std::reference_wrapper<typeinfo>(struc)));

        if (!struc.name.empty() && !struc.fields.empty())
        {
            if (this->pi.struc_tab.insert(std::make_pair(struc.name, struc)).second)
            {
                this->pi.struc_list.push_back(struc);
            }
        }
    }

    void _Load_message(const xmldrv::element & elem_message)
    {
        typeinfo msg;
        msg.name = elem_message.get_attribute_value("name", "");
        auto mode_s = elem_message.get_attribute_value("mode", "all");
        if (mode_s == "all")
            msg.mode = MODE_ALL;
        else if (mode_s == "encode")
            msg.mode = MODE_ENCODE;
        else if (mode_s == "decode")
            msg.mode = MODE_DECODE;
        else if (mode_s == "lua.encode")
            msg.mode = MODE_LUA_ENC;
        else if (mode_s == "lua.decode")
            msg.mode = MODE_LUA_DEC;
        else if (mode_s == "lua.all")
            msg.mode = MODE_LUA_ALL;
        else {
            msg.mode = MODE_NONE;
        }
        msg.zlib = elem_message.get_attribute_value("zlib", false);
        msg.command_id = elem_message.get_attribute_value("command_id", "");
        msg.is_header = elem_message.get_attribute_value("is_header", false);
        msg.action = elem_message.get_attribute_value("action", "request");
        elem_message.cforeach("field", std::bind(&pcode_autog::_Load_field, this, std::placeholders::_1, std::reference_wrapper<typeinfo>(msg)));
        std::string cid_copy = msg.command_id;
        nsc::replace(cid_copy, " ", "");

        msg.command_id_detail = nsc::split(cid_copy.c_str(), '=');

        if (!msg.name.empty() && msg.fields.size() >= 1)
        {
            this->pi.messages.push_back(msg);
        }
    }

    void _Load_field(const xmldrv::element & elem_field, typeinfo & msg)
    {
        field f;

        f.name = elem_field.get_attribute_value("name", "");
        f.type = elem_field.get_attribute_value("type", "");
        // f.specific_value = elem_field.get_attribute_value("specific_value", "");
        f.length_specifier = elem_field.get_attribute_value("length_specifier", "");
        f.present_condition = elem_field.get_attribute_value("present_condition", "");
        if (!f.name.empty() && !f.type.empty())
        {
            msg.fields.push_back(f);
        }

        f.varidic = !f.length_specifier.empty() || f.type == "std::string";

        if (!f.length_specifier.empty())
            msg.length_fields.insert(f.length_specifier);
    }

    void _Generate_constants(void)
    {
        this->constants_decl << consts_file_comments << "\n";
        _Write_start(this->constants_decl, (prefix + "constants").c_str());
        this->constants_decl << "enum {\n";
        for (auto iter = this->pi.messages.begin(); iter != this->pi.messages.end(); ++iter)
        {
            /*std::string constant = "static const int ";
            std::string detail = (*iter).name;
            detail += "_" + iiter->name + "VALUE" + " = " + iiter->specific_value + ";";
            nsc::strtoupper(const_cast<char*>(detail.c_str()));
            constant += detail;*/
            if (!iter->is_header && !iter->command_id.empty() && iter->mode <= MODE_ALL)
                this->constants_decl << ident(1) << (*iter).command_id << ",\n";

        }
        this->constants_decl << "};\n";
        _Write_end(this->constants_decl);
    }


    void _Generate_constants_lua()
    {
        std::string comments_lua = consts_file_comments;
        nsc::replace(comments_lua, "/*", "--");
        nsc::replace(comments_lua, "**", "--");
        nsc::replace(comments_lua, "*/", "--");
        this->constants_lua << comments_lua << "\n";
        // _Write_start(this->constants_decl, (prefix + "constants").c_str());
        this->constants_lua << "zysj = zysj or {}\n\n";
        for (auto iter = this->pi.messages.begin(); iter != this->pi.messages.end(); ++iter)
        {
            if (!iter->is_header && !iter->command_id.empty())
                this->constants_lua << "zysj." << (*iter).command_id << ";\n";

        }
        this->constants_lua << "\n";



        /// Generate New protocol consts
        // std::string comments_lua = consts_file_comments;
        //nsc::replace(comments_lua, "/*", "--");
        // nsc::replace(comments_lua, "**", "--");
        // nsc::replace(comments_lua, "*/", "--");
        this->protocol_const_lua << comments_lua << "\n";
        // _Write_start(this->constants_decl, (prefix + "constants").c_str());
        this->protocol_const_lua << "proto = proto or {}\n\n";
        this->protocol_const_lua << "proto.numbers = {\n";
        std::string ident_str = ident(1);
        for (auto iter = this->pi.messages.begin(); iter != this->pi.messages.end(); ++iter)
        {
            if (!iter->is_header && !iter->command_id.empty())
                this->protocol_const_lua << ident_str << (*iter).command_id << ", \n";
        }
        this->protocol_const_lua << "}\n";
    }

    void _Generate_includes(void)
    {
        auto filename = prefix + "includes";
        this->includes_decl << inc_file_comments << "\n";
        _Write_start(this->includes_decl, filename.c_str());
        this->includes_decl << "\n";
        // this->includes_decl << "#include \"simpleppdef.h\"\n";
        this->includes_decl << "#include \"yasio/ibstream.h\"\n";
        this->includes_decl << "#include \"yasio/obstream.h\"\n";
        this->includes_decl << "#include <assert.h>\n";
        this->includes_decl << "#include <vector>\n";
        this->includes_decl << "#include <iomanip>\n";
        this->includes_decl << "\n";
        _Write_end(this->includes_decl);
    }

    void _Generate_structures(void)
    {
        auto filename = prefix + "structures";
        this->structures_decl << strucs_file_comments << "\n";
        _Write_start(this->structures_decl, filename.c_str());
        this->structures_decl << "\n";
        this->structures_decl << "#include \"" << prefix << "includes.h\"\n";

        this->structures_decl << "namespace structures {\n\n";
        for (auto iter = this->pi.struc_list.begin(); iter != this->pi.struc_list.end(); ++iter)
        {
            // write a message define
            this->structures_decl << "struct " << iter->name << " {\n";
            for (auto fi = iter->fields.begin(); fi != iter->fields.end(); ++fi)
            {
                this->structures_decl << "    " << strfmt(fi->type, fi->name, ' ') << ";\n";
            }

            this->structures_decl << "};\n\n";
        }
        this->structures_decl << "};\n\n";

        this->structures_decl << "\n";
        _Write_end(this->structures_decl);
    }

    void _Generate_messages_decl(void)
    {
        auto filename = prefix + "messages";
        // generate messages file
        this->messages_decl << messages_file_comments << "\n";
        _Write_start(this->messages_decl, filename.c_str());
        this->messages_decl << "#include \"" << prefix << "constants.h\"\n";
        this->messages_decl << "#include \"" << prefix << "includes.h\"\n";
        this->messages_decl << "#include \"" << prefix << "structures.h\"\n\n";
        this->messages_decl << "#include \"iluastream.h\"\n\n";
        this->messages_decl << "#include \"oluastream.h\"\n\n";
        this->messages_decl << "using namespace structures;\n";
        this->messages_decl << "namespace messages {\n\n";
        this->messages_decl << "struct MsgBase {\n"
            << "    virtual ~MsgBase(){}\n"
            << "    virtual obstream encode(void) const { return obstream(); };\n"
            << "    virtual int decode(const char* data, int len) { return 25001; };\n"
            << "    virtual int decodeLua(lua_State* L) { return 25002; };\n"
            << "    virtual int encodeLua(lua_State* L) const { return 25002; };\n"
            << "    virtual int get_id(void) const { return -1; };\n"
            << "    virtual const char* get_className() const { return \"MsgBase\"; };\n"
            << "};\n\n";
        for (auto mi = this->pi.messages.begin(); mi != this->pi.messages.end(); ++mi)
        {
            if (mi->mode > MODE_ALL)
                continue; // skip pure lua for message decl.

            // write a message define
            if (mi->is_header)
                this->messages_decl << "struct " << mi->name << " {\n";
            else
                this->messages_decl << "struct " << mi->name << " : public MsgBase {\n";
            for (auto fi = mi->fields.begin(); fi != mi->fields.end(); ++fi)
            {
                this->messages_decl << "    " << strfmt(fi->type, fi->name, ' ') << ";\n";
            }
            this->messages_decl << "\n";


            // message codecs declarations and to string function
            // write a message codec declaration
            // this->messages_decl << "    " << mi->name << "(void);\n\n";

            if (!mi->is_header) {
                if (mi->mode & MODE_ENCODE)
                    this->messages_decl << "    obstream encode(void)  const override;\n\n";

                if (mi->mode & MODE_DECODE) {
                    this->messages_decl << "    // decode return the remain bytes of buffer.\n";
                    this->messages_decl << "    int decode(const char* data, int len) override;\n\n";
                }

                this->messages_decl << "    // decode LUA.\n";
                this->messages_decl << "    virtual int decodeLua(lua_State* L) override;\n\n";
                this->messages_decl << "    virtual int encodeLua(lua_State* L) const override;\n\n";
                this->messages_decl << "    int get_id() const override { return " << mi->command_id_detail.at(0) << "; };\n\n";
                this->messages_decl << "    const char* get_className() const override { return \"" << mi->name << "\"; };\n\n";
            }
            else {
                if (mi->mode & MODE_ENCODE)
                    this->messages_decl << "    obstream encode(void) const;\n\n";

                if (mi->mode & MODE_DECODE) {
                    this->messages_decl << "    // decode return the remain bytes of buffer.\n";
                    this->messages_decl << "    int decode(const char* data, int len);\n\n";
                }
            }

            this->messages_decl << "    std::string get_formated_string(void) const;\n";
            this->messages_decl << "};\n\n";
        }

        this->messages_decl << "// Remark: this function just create a temp message, and it not thread-safety, don't save the pointer any time!;\n";
        this->messages_decl << "//     and do not use when message large than 16384Byte, 16K.\n";
        this->messages_decl << "MsgBase* temp_create_message(int command_id);\n";

        this->messages_decl << "}; /*namespace messages*/\n\n";
        _Write_end(this->messages_decl);
    }

    void _Generate_messages_impl(void)
    {
        // generate messages codec header file

        // generate messages codec implement file
        this->messages_impl << messages_file_comments << "\n";
        this->messages_impl << "#include \"" << prefix << "messages.h\"\n\n";
        this->messages_impl << "#include \"" << prefix << "constants.h\"\n\n";
        this->messages_impl << "#include <unordered_map>\n\n";
        this->messages_impl << "#include <functional>\n\n";
        this->messages_impl << "#include \"purelib/utils/crypto_wrapper.h\"\n\n";
        // this->messages_impl << "using namespace exx::net;\n";
        this->messages_impl << "using namespace messages;\n\n";

        this->messages_impl << "// pcode_autog_create_header implemented by user.\n";
        this->messages_impl << "extern obstream pcode_autog_begin_encode(uint16_t command_id, uint16_t reserved = 0x6102);\n\n";



        std::string comments_lua = messages_file_comments;
        nsc::replace(comments_lua, "/*", "--");
        nsc::replace(comments_lua, "**", "--");
        nsc::replace(comments_lua, "*/", "--");

        this->protocol_enc_lua << comments_lua << "\n";
        this->protocol_enc_lua << "-- Implement all pure lua protocol encode functions.\n";
        this->protocol_enc_lua << "require 'protocol_enums'\n\n";

        this->protocol_dec_lua << comments_lua << "\n";
        this->protocol_dec_lua << "-- Implement all pure lua protocol decode functions.\n";
        this->protocol_dec_lua << "require 'protocol_enums'\n\n";


        for (auto mi = this->pi.messages.begin(); mi != this->pi.messages.end(); ++mi)
        {
            if (mi->mode > MODE_ALL)
            { // generate for lua

                /* generate decode function implement, write to protocol_enc.lua
                 function prototype: input: a lua plain message table, return: obs
                 proto.e10053 = function(msg)
                 end
                 */
                if (mi->mode & MODE_LUA_ENC)
                {
                    this->protocol_enc_lua << "proto.e" << mi->command_id_detail.at(1) << " = function(msg)\n";
                    // this->messages_impl << "    " << "obstream obs;\n";
                    assert(!mi->is_header); // must be not header.

                    this->protocol_enc_lua << ident(1) << "-- begin message encode.\n";
                    this->protocol_enc_lua << ident(1) << "local obs = proto.begin_encode(proto.numbers." << mi->command_id_detail.at(0) << ");\n\n"; // create with header? YES currently.
                    // this->protocol_enc_lua << ident(1) << "obs.__purelua = true; -- For recognize automaticall\n\n";

                    if (mi->zlib)
                    {
                        this->protocol_enc_lua << ident(1) << "local offset = " << "obs:length(); -- offset for body compress.\n\n";
                    }

                    this->protocol_enc_lua << ident(1) << "-- encode message fields.\n";
                    for (auto fi = mi->fields.begin(); fi != mi->fields.end(); ++fi) {
                        _To_netval_lua(this->protocol_enc_lua, *mi, *fi, "msg.", 1);
                    }

                    if (!mi->is_header && mi->zlib) {
                        this->protocol_enc_lua << ident(1) << "obs:compress(offset); -- do body compress.\n\n";
                    }

                    this->protocol_enc_lua << "\n    -- finish message encode.";
                    this->protocol_enc_lua << "\n    obs:pop32(); -- finish encode\n";

                    this->protocol_enc_lua << "\n    return obs;\n";

                    this->protocol_enc_lua << "end\n\n";
                }

                /* generate decode function implement, write to protocol_dec.lua
                function prototype: input: ibs, return: a lua plain message table
                proto.d10053 = function(ibs)
                end
                */
                if (mi->mode & MODE_LUA_DEC)
                {
                    assert(!mi->is_header); // must be not header.

                    //this->messages_impl << "int " << mi->name << "::decode(const char* data, int len)\n{\n";
                    //this->messages_impl << "    " << "ibstream_view ibs;\n";

                    this->protocol_dec_lua << "proto.d" << mi->command_id_detail.at(1) << " = function(ibs)\n";
                    // this->messages_impl << "    " << "obstream obs;\n";

                    /*if (mi->is_header || !mi->zlib)
                    {
                    this->messages_impl << "    " << "ibs.vassign(data, len);\n\n";
                    }
                    else {*/
                    //this->protocol_dec_lua << "    " << "auto uncompr = crypto::zlib::abi::inflate(unmanaged_string(data, len)); \n";
                    //this->protocol_dec_lua << "    " << "ibs.vassign(uncompr.data(), uncompr.size());\n\n";
                    /* }*/
                    this->protocol_dec_lua << "    " << "local msg = proto.begin_decode(ibs);\n\n";

                    for (auto fi = mi->fields.begin(); fi != mi->fields.end(); ++fi) {
                        _To_hostval_lua(this->protocol_dec_lua, *mi, *fi, "msg.", 1);
                    }
                    this->protocol_dec_lua << "\n    return msg;\n";
                    this->protocol_dec_lua << "end\n\n";
                }

                continue;
            }
            // constructor
            //this->messages_impl << mi->name << "::" << mi->name << "(void)\n{\n";
            //this->messages_impl << "    memset(this, 0x0, sizeof(*this));\n";
            // this->messages_impl << "    this->mt_ = " << mi->fields[0].specific_value << ";\n";
            //this->messages_impl << "}\n\n";

            if (mi->mode & MODE_ENCODE)
            { // encode
                this->messages_impl << "obstream " << mi->name << "::encode(void) const\n{\n";
                // this->messages_impl << "    " << "obstream obs;\n";

                if (!mi->is_header)
                {
                    this->messages_impl << ident(1) << "/// create message header stream.\n";
                    this->messages_impl << ident(1) << "auto obs = pcode_autog_begin_encode(" << mi->command_id_detail.at(0) << ");\n\n";
                    if (mi->zlib)
                    {
                        this->messages_impl << ident(1) << "auto offset = " << "obs.length(); // offset for body compress.\n\n";
                    }
                }
                else {
                    this->messages_impl << ident(1) << "obstream obs;\n\n";
                }

                this->messages_impl << ident(1) << "/// encode message fields.\n";
                for (auto fi = mi->fields.begin(); fi != mi->fields.end(); ++fi) {
                    _To_netval(this->messages_impl, *mi, *fi, "this->", 1);
                }

                if (!mi->is_header && mi->zlib) {
                    this->messages_impl << ident(1) << "obs.compress(offset); // do body compress.\n\n";
                }

                this->messages_impl << ident(1) << "return obs;\n";

                this->messages_impl << "}\n\n";

            }

            if (mi->mode & MODE_DECODE)
            { // decode
                this->messages_impl << "int " << mi->name << "::decode(const char* data, int len)\n{\n";
                this->messages_impl << "    " << "ibstream_view ibs;\n";

                if (mi->is_header || !mi->zlib)
                {
                    this->messages_impl << "    " << "ibs.assign(data, len);\n\n";
                }
                else { // generate custom inflate source
                    /*this->messages_impl << "    " << "auto uncompr = crypto::zlib::abi::inflate(unmanaged_string(data, len)); \n";
                    this->messages_impl << "    " << "ibs.assign(uncompr.data(), uncompr.size());\n\n";*/
                }

                for (auto fi = mi->fields.begin(); fi != mi->fields.end(); ++fi) {
                    _To_hostval(this->messages_impl, *mi, *fi, "this->", 1);
                }
                this->messages_impl << "    return ibs.remain();\n";
                this->messages_impl << "}\n\n";
            }

            // formated message information
            this->messages_impl << "std::string " << mi->name << "::get_formated_string(void) const\n{\n";
            this->messages_impl << "    std::stringstream ss;\n";
            this->messages_impl << "    ss << \"" << mi->name << ":\\n\";\n";
            for (auto fi = mi->fields.begin(); fi != mi->fields.end(); ++fi) {
                _Append_string(this->messages_impl, *mi, *fi, "this->", 1);
            }
            this->messages_impl << "    return ss.str();\n";
            this->messages_impl << "}\n\n";

            /////// LUA SUPPORT ///////
            if (!mi->is_header)
            {
#if 1 // decode from lua talbe
                this->messages_impl << "int " << mi->name << "::decodeLua(lua_State* L)\n{\n";
                this->messages_impl << "    auto top = lua_gettop(L);\n";
                this->messages_impl << "    " << "iluastream ibs(L);\n";
                for (auto fi = mi->fields.begin(); fi != mi->fields.end(); ++fi) {
                    lua2host_context ctx;
                    ctx.prefix = "this->";
                    lua2host(this->messages_impl, *mi, *fi, "this->", ctx, 1);
                }
                //  this->messages_impl << "    return ibs.remain();\n";
                this->messages_impl << "\n    auto check = lua_gettop(L);\n";
                this->messages_impl << "\n    assert(top == check);\n";
                this->messages_impl << "\n    return 0;\n";
                this->messages_impl << "}\n\n";
#endif

#if 1 // encode to lua table
                this->messages_impl << "int " << mi->name << "::encodeLua(lua_State* L) const \n{\n";
                this->messages_impl << "    auto top = lua_gettop(L);\n";
                this->messages_impl << "    " << "oluastream obs(L);\n";
                this->messages_impl << "    " << "lua_newtable(L);\n";
                for (auto fi = mi->fields.begin(); fi != mi->fields.end(); ++fi) {
                    host2lua_context ctx;
                    ctx.prefix = "this->";
                    host2lua(this->messages_impl, *mi, *fi, "this->", ctx, 1);
                }
                this->messages_impl << "\n    auto check = lua_gettop(L);\n";
                this->messages_impl << "\n    assert(check > top );\n";
                this->messages_impl << "\n    return 0;\n";
                this->messages_impl << "}\n\n";
#endif
            }

        }

        /// generate temp_create_message func code
        this->messages_impl << "static char s_allocp[16384]; // static alloc memory.\n";
        this->messages_impl << "static std::unordered_map<int, std::function<MsgBase*(void)>> s_table_message_ctor;\n";
        this->messages_impl <<
            "MsgBase* messages::temp_create_message(int command_id)\n{\n"
            "    auto target = s_table_message_ctor.find(command_id);\n"
            "    if(target != s_table_message_ctor.end())\n"
            "        return (target->second)();\n"
            // "    assert(false);\n"
            "    return nullptr;\n";
        this->messages_impl << "}\n\n";

        /// construct table use c++ preinit
        this->messages_impl <<
            "static int internal_message_ctor_table_preinit(void)\n{\n";

        for (auto& mi : this->pi.messages)
        {
            if (!mi.is_header) {
                if (mi.mode <= MODE_ALL) {
                    this->messages_impl << "    s_table_message_ctor[" << mi.command_id_detail[0] << "]" <<
                        "= []()->MsgBase*{ return new(s_allocp) " << mi.name << "(); };\n";
                }
            }
        }

        this->messages_impl << "    return 0;\n";
        this->messages_impl << "}\n\n";

        this->messages_impl << "static const int __TABLE_INIT_PLACE_HOLDER = internal_message_ctor_table_preinit();\n\n";


        // write end of protocol.enc
        this->protocol_enc_lua << "\n";
        this->protocol_dec_lua << "\n";
    }

    void _To_netval_lua(std::ostream & of, const typeinfo & ti, const field & f, const std::string & prefix, int deep = 1)
    {
        std::string ident_str = ident(deep);
#if 0 // disable condition support
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident_str << "if(" << f.present_condition << ")\n";
            of << ident_str << "{\n";
            ident_str = ident(++deep);
        }
#endif

        if (is_single_type_of_field(f))
        {
            std::string sig;
            if (is_basic_type(f.type, &sig))
            {
                if (!is_fixed_array_type(f.name))
                    of << ident_str << "obs:write_" << sig << "(" << prefix << f.name << ");\n";
                else { // MAY NOT support byte array
                    abort();
                    /*of << ident_str << "obs:write_bytes(" << prefix << f.name << ", "
                        << "sizeof (" << f.name << ") );\n";*/
                }
                /*if(is_oneb_type(f.type)){
                of << ident_str << "*( (" << f.type << "*)ptr ) = " << prefix << f.name << ", ++ptr;\n";
                }
                else {
                of << ident_str << "purelib::endian::htonv(" << prefix << f.name << ", ptr);\n";
                }*/
            }
            else if (is_string_type(f.type)) {
                of << ident_str << "obs:write_v(" << prefix << f.name << ");\n";
            }
            else
            {
                auto target = this->pi.struc_tab.find(f.type);
                if (target != this->pi.struc_tab.end())
                {
                    for (auto iter = target->second.fields.begin(); iter != target->second.fields.end(); ++iter)
                    {
                        _To_netval_lua(of, target->second, *iter, prefix + f.name + ".", deep);
                    }
                }
                else
                {
                    std::cerr << "generate code failed, the type: " << f.type << " is not defined yet!\n";
                    std::cin.get();
                    exit(-1);
                }
            }
        }
        else
        { // TODO: to implement
            std::string length_symbol;
            std::string num_of_cpy;
            std::string loop_condition;
            std::string length_specifier_type;
            _Get_length_corresponds(ti, f, length_symbol, num_of_cpy, loop_condition, length_specifier_type, prefix);

            if (is_variable_pointer(f))
            { // !!! never go here for Lua.
                //of << ident_str << "if(" << length_symbol << " != 0) then";
                //of << "assert(" << prefix << f.name << "!= nullptr);\n";
            }

            std::string varname_vecsize = f.name + "_size";
            /*		if (is_stl_vector(f)) {
            of << ident_str << "uint16_t " << varname_vecsize << "; \n"
            << ident_str << "ibs.read_i(" << varname_vecsize << ");\n";
            }*/
            if (is_stl_vector(f))
            {
                of << ident_str << "local " << varname_vecsize << " = #(" << prefix << f.name << ");\n";
                of << ident_str << "obs:write_u16(" << varname_vecsize << ");\n";
            }

            if (!num_of_cpy.empty())
            { // never go here currently
                of << ident_str << "obs.write_bytes(" << prefix << get_field_name(f) << ", " << num_of_cpy << ");\n";
            }
            else {
                if (is_stl_vector(f)) {
                    std::string index_var_name = get_array_field_trim_name(f.name) + "index";

                    // loop_condition.append(varname_vecsize);

                    of << ident_str << "local " << index_var_name << " = 0;\n";
                    //of << ident_str << "for(uint16_t " << index_var_name << " = 0; " << loop_condition << "; ++" << index_var_name << ")\n";
                    //of << ident_str << "{\n";
                    of << ident_str << "while(" << loop_condition << ") do\n";
                    of << ident_str << ident_str << index_var_name << " = " << index_var_name << " + 1;\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;

                    std::string::size_type pos = f.name.find_first_of('[');
                    new_prefix = prefix + (f.name.substr(0, pos) + "[" + index_var_name + "]");

                    pos = f.type.find_first_of('<');
                    temp.type = f.type.substr(pos + 1, f.type.find_first_of('>') - pos - 1);

                    _To_netval_lua(of, ti, temp, new_prefix, deep + 1);

                    of << ident_str << "end\n";
                }
                else {
                    std::string index_var_name = get_array_field_trim_name(f.name) + "index";

                    of << ident_str << "local " << index_var_name << " = 0;\n";
                    //of << ident_str << "for(" << length_specifier_type << " " << index_var_name << " = 0; " << loop_condition << "; ++" << index_var_name << ")\n";
                    //of << ident_str << "{\n";
                    of << ident_str << "while(" << loop_condition << ") do\n";
                    of << ident_str << ident_str << index_var_name << " = " << index_var_name << " + 1;\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;
                    if (is_variable_pointer(f))
                    {
                        new_prefix = prefix + f.name + "[" + index_var_name + "]";
                        temp.type.pop_back();
                    }
                    else
                    {
                        std::string::size_type pos = f.name.find_first_of('[');
                        new_prefix = prefix + (f.name.substr(0, pos) + "[" + index_var_name + "]");
                    }
                    _To_netval_lua(of, ti, temp, new_prefix, deep + 1);
                    of << ident_str << "end\n";
                }
            }
        }
        --deep;

#if 0 // disable condition support
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident(deep) << "}\n";
        }
#endif
    }

    void _To_hostval_lua(std::ostream & of, const typeinfo & ti, const field & f, const std::string & prefix, int deep = 1)
    {
        std::string ident_str = ident(deep);

#if 0
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident_str << "if(" << f.present_condition << ")\n";
            of << ident_str << "{\n";
            ident_str = ident(++deep);
        }
#endif

        if (is_single_type_of_field(f))
        {
            std::string sig;
            if (is_basic_type(f.type, &sig))
            {
                /*if(is_oneb_type(f.type)){
                of << ident_str << prefix << f.name << " = *( (" << f.type << "*)ptr )"  << ", ++ptr;\n";
                }
                else {*/
                if (!is_fixed_array_type(f.name))
                    of << ident_str << prefix << f.name << " = " << "ibs:read_" << sig << "(); \n";
                else
                    assert(false);// of << ident_str << "ibs.read_bytes(" << prefix << f.name << ", " << "sizeof(" << f.name << ") );\n";; // TODO: implement
            }
            else if (is_string_type(f.type)) {
                of << ident_str << prefix << f.name << " = " << "ibs:read_v();\n";
            }
            else
            {
                auto target = this->pi.struc_tab.find(f.type);
                if (target != this->pi.struc_tab.end())
                {
                    for (auto iter = target->second.fields.begin(); iter != target->second.fields.end(); ++iter)
                    {
                        _To_hostval_lua(of, target->second, *iter, prefix + f.name + ".", deep);
                    }
                }
                else
                {
                    std::cerr << "generate code failed, the type: " << f.type << " is not defined yet!\n";
                    std::cin.get();
                    exit(-1);
                }
            }
        }
        else
        {
            std::string length_symbol;
            std::string num_of_cpy;
            std::string loop_condition;
            std::string length_specifier_type;
            _Get_length_corresponds(ti, f, length_symbol, num_of_cpy, loop_condition, length_specifier_type, prefix);

#if 0
            if (is_variable_pointer(f))
            {
                of << ident_str << "if(" << length_symbol << " != 0) ";
                of << "assert(" << prefix << f.name << "!= nullptr);\n";
            }
#endif

            std::string varname_vecsize = f.name + "_size";
            if (is_stl_vector(f)) {
                of << ident_str << "local " << varname_vecsize << " = ibs:read_u16();\n";
            }

            if (!num_of_cpy.empty())
            { // do not support currently
                assert(false);// of << ident_str << "ibs.read_bytes(" << prefix << get_field_name(f) << ", " << num_of_cpy << ");\n";
            }
            else {
                if (is_stl_vector(f)) {
                    std::string varname_vecidx = get_array_field_trim_name(f.name) + "index";



                    //of << ident_str << prefix << f.name << ".resize(" << varname_vecsize << ");\n";
                    //of << ident_str << "for(uint16_t " << varname_vecidx << " = 0; " << varname_vecidx << " < " << varname_vecsize << "; ++" << varname_vecidx << ")\n";
                    //of << ident_str << "{\n";
                    loop_condition.append(varname_vecsize);

                    of << ident_str << prefix << f.name << " = {};\n";
                    of << ident_str << "local " << varname_vecidx << " = 0;\n";
                    of << ident_str << "while(" << loop_condition << ") do\n";
                    of << ident_str << ident_str << varname_vecidx << " = " << varname_vecidx << " + 1;\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;

                    std::string::size_type pos = f.name.find_first_of('[');
                    new_prefix = prefix + (f.name.substr(0, pos) + "[" + varname_vecidx + "]");

                    pos = f.type.find_first_of('<');
                    temp.type = f.type.substr(pos + 1, f.type.find_first_of('>') - pos - 1);

                    of << ident_str << ident_str << new_prefix << " = {};\n";
                    _To_hostval_lua(of, ti, temp, new_prefix, deep + 1);
                    of << ident_str << "end\n";
                }
                else { // fixed array not support for current lua
                    // assert(false);
                    std::string index_var_name = get_array_field_trim_name(f.name) + "index";
                    //of << ident_str << "for(" << length_specifier_type << " " << index_var_name << " = 0; " << loop_condition << "; ++" << index_var_name << ")\n";
                    //of << ident_str << "{\n";
                    of << ident_str << "local " << index_var_name << " = 0;\n";
                    of << ident_str << "while(" << loop_condition << ") do\n";
                    of << ident_str << ident_str << index_var_name << " = " << index_var_name << " + 1;\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;
                    if (is_variable_pointer(f))
                    {
                        new_prefix = prefix + f.name + "[" + index_var_name + "]";
                        temp.type.pop_back();
                    }
                    else
                    {
                        std::streamoff pos = f.name.find_first_of('[');
                        new_prefix = prefix + (f.name.substr(0, pos) + "[" + index_var_name + "]");
                    }
                    _To_hostval(of, ti, temp, new_prefix, deep + 1);
                    of << ident_str << "end\n";
                }
            }
        }
        --deep;

#if 0
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident(deep) << "}\n";
        }
#endif
    }

    void _To_netval(std::ostream & of, const typeinfo & ti, const field & f, const std::string & prefix, int deep = 1)
    {
        std::string ident_str = ident(deep);
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident_str << "if(" << f.present_condition << ")\n";
            of << ident_str << "{\n";
            ident_str = ident(++deep);
        }

        if (is_single_type_of_field(f))
        {
            if (is_basic_type(f.type))
            {
                if (!is_fixed_array_type(f.name))
                    of << ident_str << "obs.write_i(" << prefix << f.name << ");\n";
                else
                    of << ident_str << "obs.write_bytes(" << prefix << f.name << ", "
                    << "sizeof (" << f.name << ") );\n";
                /*if(is_oneb_type(f.type)){
                    of << ident_str << "*( (" << f.type << "*)ptr ) = " << prefix << f.name << ", ++ptr;\n";
                    }
                    else {
                    of << ident_str << "purelib::endian::htonv(" << prefix << f.name << ", ptr);\n";
                    }*/
            }
            else if (is_string_type(f.type)) {
                of << ident_str << "obs.write_v(" << prefix << f.name << ");\n";
            }
            else
            {
                auto target = this->pi.struc_tab.find(f.type);
                if (target != this->pi.struc_tab.end())
                {
                    for (auto iter = target->second.fields.begin(); iter != target->second.fields.end(); ++iter)
                    {
                        _To_netval(of, target->second, *iter, prefix + f.name + ".", deep);
                    }
                }
                else
                {
                    std::cerr << "generate code failed, the type: " << f.type << " is not defined yet!\n";
                    std::cin.get();
                    exit(-1);
                }
            }
        }
        else
        { // TODO: to implement
            std::string length_symbol;
            std::string num_of_cpy;
            std::string loop_condition;
            std::string length_specifier_type;
            _Get_length_corresponds(ti, f, length_symbol, num_of_cpy, loop_condition, length_specifier_type, prefix);

            if (is_variable_pointer(f))
            {
                of << ident_str << "if(" << length_symbol << " != 0) ";
                of << "assert(" << prefix << f.name << "!= nullptr);\n";
            }

            std::string varname_vecsize = f.name + "_size";
            /*		if (is_stl_vector(f)) {
                        of << ident_str << "uint16_t " << varname_vecsize << "; \n"
                        << ident_str << "ibs.read_i(" << varname_vecsize << ");\n";
                        }*/
            if (is_stl_vector(f))
            {
                of << ident_str << "auto " << varname_vecsize << " = static_cast<uint16_t>(" << prefix << f.name << ".size());\n";
                of << ident_str << "obs.write_i(" << varname_vecsize << ");\n";
            }

            if (!num_of_cpy.empty())
            {
                of << ident_str << "obs.write_bytes(" << prefix << get_field_name(f) << ", " << num_of_cpy << ");\n";
            }
            else {
                if (is_stl_vector(f)) {
                    std::string index_var_name = get_array_field_trim_name(f.name) + "index";

                    loop_condition.append(varname_vecsize);

                    of << ident_str << "for(uint16_t " << index_var_name << " = 0; " << loop_condition << "; ++" << index_var_name << ")\n";
                    of << ident_str << "{\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;

                    std::string::size_type pos = f.name.find_first_of('[');
                    new_prefix = prefix + (f.name.substr(0, pos) + "[" + index_var_name + "]");

                    pos = f.type.find_first_of('<');
                    temp.type = f.type.substr(pos + 1, f.type.find_first_of('>') - pos - 1);

                    _To_netval(of, ti, temp, new_prefix, deep + 1);
                    of << ident_str << "}\n";
                }
                else {
                    std::string index_var_name = get_array_field_trim_name(f.name) + "index";
                    of << ident_str << "for(" << length_specifier_type << " " << index_var_name << " = 0; " << loop_condition << "; ++" << index_var_name << ")\n";
                    of << ident_str << "{\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;
                    if (is_variable_pointer(f))
                    {
                        new_prefix = prefix + f.name + "[" + index_var_name + "]";
                        temp.type.pop_back();
                    }
                    else
                    {
                        std::string::size_type pos = f.name.find_first_of('[');
                        new_prefix = prefix + (f.name.substr(0, pos) + "[" + index_var_name + "]");
                    }
                    _To_netval(of, ti, temp, new_prefix, deep + 1);
                    of << ident_str << "}\n";
                }
            }
        }
        --deep;
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident(deep) << "}\n";
        }
    }

    void _To_hostval(std::ostream & of, const typeinfo & ti, const field & f, const std::string & prefix, int deep = 1)
    {
        std::string ident_str = ident(deep);

        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident_str << "if(" << f.present_condition << ")\n";
            of << ident_str << "{\n";
            ident_str = ident(++deep);
        }

        if (is_single_type_of_field(f))
        {
            if (is_basic_type(f.type))
            {
                /*if(is_oneb_type(f.type)){
                    of << ident_str << prefix << f.name << " = *( (" << f.type << "*)ptr )"  << ", ++ptr;\n";
                    }
                    else {*/
                if (!is_fixed_array_type(f.name))
                    of << ident_str << "ibs.read_i(" << prefix << f.name << ");\n";
                else
                    of << ident_str << "ibs.read_bytes(" << prefix << f.name << ", " << "sizeof(" << f.name << ") );\n";; // TODO: implement
            }
            else if (is_string_type(f.type)) {
                of << ident_str << "ibs.read_v(" << prefix << f.name << ");\n";
            }
            else
            {
                auto target = this->pi.struc_tab.find(f.type);
                if (target != this->pi.struc_tab.end())
                {
                    for (auto iter = target->second.fields.begin(); iter != target->second.fields.end(); ++iter)
                    {
                        _To_hostval(of, target->second, *iter, prefix + f.name + ".", deep);
                    }
                }
                else
                {
                    std::cerr << "generate code failed, the type: " << f.type << " is not defined yet!\n";
                    std::cin.get();
                    exit(-1);
                }
            }
        }
        else
        {
            std::string length_symbol;
            std::string num_of_cpy;
            std::string loop_condition;
            std::string length_specifier_type;
            _Get_length_corresponds(ti, f, length_symbol, num_of_cpy, loop_condition, length_specifier_type, prefix);

            if (is_variable_pointer(f))
            {
                of << ident_str << "if(" << length_symbol << " != 0) ";
                of << "assert(" << prefix << f.name << "!= nullptr);\n";
            }

            std::string varname_vecsize = f.name + "_size";
            if (is_stl_vector(f)) {
                of << ident_str << "uint16_t " << varname_vecsize << "; \n"
                    << ident_str << "ibs.read_i(" << varname_vecsize << ");\n";
            }

            if (!num_of_cpy.empty())
            {
                of << ident_str << "ibs.read_bytes(" << prefix << get_field_name(f) << ", " << num_of_cpy << ");\n";
            }
            else {
                if (is_stl_vector(f)) {
                    std::string varname_vecidx = get_array_field_trim_name(f.name) + "index";

                    loop_condition.append(f.name).append(".size())");

                    of << ident_str << prefix << f.name << ".resize(" << varname_vecsize << ");\n";
                    of << ident_str << "for(uint16_t " << varname_vecidx << " = 0; " << varname_vecidx << " < " << varname_vecsize << "; ++" << varname_vecidx << ")\n";
                    of << ident_str << "{\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;

                    std::string::size_type pos = f.name.find_first_of('[');
                    new_prefix = prefix + (f.name.substr(0, pos) + "[" + varname_vecidx + "]");

                    pos = f.type.find_first_of('<');
                    temp.type = f.type.substr(pos + 1, f.type.find_first_of('>') - pos - 1);

                    _To_hostval(of, ti, temp, new_prefix, deep + 1);
                    of << ident_str << "}\n";
                }
                else {
                    std::string index_var_name = get_array_field_trim_name(f.name) + "index";
                    of << ident_str << "for(" << length_specifier_type << " " << index_var_name << " = 0; " << loop_condition << "; ++" << index_var_name << ")\n";
                    of << ident_str << "{\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;
                    if (is_variable_pointer(f))
                    {
                        new_prefix = prefix + f.name + "[" + index_var_name + "]";
                        temp.type.pop_back();
                    }
                    else
                    {
                        std::streamoff pos = f.name.find_first_of('[');
                        new_prefix = prefix + (f.name.substr(0, pos) + "[" + index_var_name + "]");
                    }
                    _To_hostval(of, ti, temp, new_prefix, deep + 1);
                    of << ident_str << "}\n";
                }
            }
        }
        --deep;
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident(deep) << "}\n";
        }
    }

    struct lua2host_context {
        std::string prefix;
        std::string arrayIndex;
    };

    void lua2host(std::ostream & of, const typeinfo & ti, const field & f, const std::string & prefix, lua2host_context & context, int deep = 1)
    { // TODO: use convert context.
        std::string ident_str = ident(deep);

        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident_str << "if(" << f.present_condition << ")\n";
            of << ident_str << "{\n";
            ident_str = ident(++deep);
        }

        if (is_single_type_of_field(f))
        {
            if (is_basic_type(f.type))
            {
                bool isNameEmpty = f.name.empty();
                if (!isNameEmpty) {
                    if (!is_fixed_array_type(f.name)) // TODO: use convert context to determine whether element of array 
                    {
                        of << ident_str << "ibs.read_i(\"" << f.name << "\"," << prefix << f.name << "); \n";
                    }
                    else
                    {
                        of << ident_str << "ibs.read_v(\"" << f.name << "\", " << prefix << get_field_name(f) << ", sizeof(" << f.name << ") );\n";; // TODO: implement
                    }
                }
                else {
                    of << ident_str << "ibs.read_i(" << context.arrayIndex << " + 1, " << prefix << f.name << "); \n";
                }
            }
            else if (is_string_type(f.type)) {
                of << ident_str << "ibs.read_v(\"" << f.name << "\"," << prefix << f.name << ");\n";
            }
            else
            {
                if (!f.name.empty()) // should be item of stl-vector
                    of << ident_str << "lua_getfield(L, -1, \"" << f.name << "\");\n";
                of << ident_str << "assert(lua_istable(L, -1)); \n";
                auto target = this->pi.struc_tab.find(f.type);
                if (target != this->pi.struc_tab.end())
                { // structure
                    for (auto iter = target->second.fields.begin(); iter != target->second.fields.end(); ++iter)
                    {
                        lua2host(of, target->second, *iter, prefix + f.name + ".", context, deep);
                    }
                    of << ident_str << "lua_pop(L, 1);\n";
                }
                else
                {
                    std::cerr << "generate code failed, the type: " << f.type << " is not defined yet!\n";
                    std::cin.get();
                    exit(-1);
                }
            }
        }
        else
        {
            std::string length_symbol;
            std::string num_of_cpy;
            std::string loop_condition;
            std::string length_specifier_type;
            _Get_length_corresponds(ti, f, length_symbol, num_of_cpy, loop_condition, length_specifier_type, prefix);

            if (is_variable_pointer(f))
            {
                of << ident_str << "if(" << length_symbol << " != 0) ";
                of << "assert(" << prefix << f.name << "!= nullptr);\n";
            }

            std::string varname_vecsize = f.name + "_size";
            //if (is_stl_vector(f)) {
            //    
            //}

            if (!num_of_cpy.empty())
            {
                of << ident_str << "ibs.read_v(\"" << get_field_name(f) << "\", " << prefix << get_field_name(f) << ", " << num_of_cpy << "); \n";
            }
            else {
                if (is_stl_vector(f)) {
                    if (!f.name.empty())
                        of << ident_str << "lua_getfield(L, -1, \"" << f.name << "\");\n";
                    of << ident_str << "assert(lua_istable(L, -1)); \n";
                    of << ident_str << "uint16_t " << varname_vecsize << " = luaL_getn(L, -1); \n"
                        /*<< ident_str << "ibs.read_i(" << varname_vecsize << ");\n"*/;

                    std::string varname_vecidx = get_array_field_trim_name(f.name) + "index";

                    loop_condition.append(f.name).append(".size())");

                    of << ident_str << prefix << f.name << ".resize(" << varname_vecsize << ");\n";
                    of << ident_str << "for(uint16_t " << varname_vecidx << " = 0; " << varname_vecidx << " < " << varname_vecsize << "; ++" << varname_vecidx << ")\n";
                    of << ident_str << "{\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;

                    std::string::size_type pos = f.name.find_first_of('[');
                    new_prefix = prefix + (f.name.substr(0, pos) + "[" + varname_vecidx + "]");

                    pos = f.type.find_first_of('<');
                    temp.type = f.type.substr(pos + 1, f.type.find_first_of('>') - pos - 1);

                    context.prefix = new_prefix;
                    context.arrayIndex = varname_vecidx;

                    if (!is_basic_type(parse_item_type(f.type))) // ignore base type array
                        of << ident_str << "    lua_rawgeti(L, -1, " << varname_vecidx << " + 1); \n";

                    lua2host(of, ti, temp, new_prefix, context, deep + 1); // recursively

                    of << ident_str << "}\n";

                    of << ident_str << "lua_pop(L, 1);\n";
                }
                else { // maybe never go here
                    assert(false);
                    if (!f.name.empty())
                        of << ident_str << "lua_getfield(L, -1, \"" << f.name << "\");\n";
                    of << ident_str << "assert(lua_istable(L, -1)); \n";

                    std::string index_var_name = get_array_field_trim_name(f.name) + "index";
                    of << ident_str << "for(" << length_specifier_type << " " << index_var_name << " = 0; " << loop_condition << "; ++" << index_var_name << ")\n";
                    of << ident_str << "{\n";



                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;
                    if (is_variable_pointer(f))
                    {
                        new_prefix = prefix + f.name + "[" + index_var_name + "]";
                        temp.type.pop_back();
                    }
                    else
                    {
                        std::streamoff pos = f.name.find_first_of('[');
                        new_prefix = prefix + (f.name.substr(0, pos) + "[" + index_var_name + "]");
                    }
                    lua2host(of, ti, temp, new_prefix, context, deep + 1);
                    of << ident_str << "}\n";

                    of << ident_str << "lua_pop(L, 1);\n";
                }
            }
        }
        --deep;
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident(deep) << "}\n";
        }
    }

    struct host2lua_context {
        std::string prefix;
        std::string arrayIndex;
    };

    void host2lua(std::ostream & of, const typeinfo & ti, const field & f, const std::string & prefix, host2lua_context & ctx, int deep = 1)
    {
        std::string ident_str = ident(deep);
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident_str << "if(" << f.present_condition << ")\n";
            of << ident_str << "{\n";
            ident_str = ident(++deep);
        }

        if (is_single_type_of_field(f))
        {
            if (is_basic_type(f.type))
            { // TODO: check name is empty
                if (!f.name.empty()) {
                    if (!is_fixed_array_type(f.name))
                        of << ident_str << "obs.write_i(\"" << f.name << "\"," << prefix << f.name << ");\n";
                    else
                        of << ident_str << "obs.write_v(\"" << f.name << "\"," << prefix << f.name << ", "
                        << "sizeof (" << f.name << ") );\n";
                }
                else {
                    of << ident_str << "obs.write_i(" << ctx.arrayIndex << " + 1, " << prefix << f.name << "); \n";
                }
            }
            else if (is_string_type(f.type)) {
                of << ident_str << "obs.write_v(\"" << f.name << "\"," << prefix << f.name << ");\n";
            }
            else
            {
                auto target = this->pi.struc_tab.find(f.type);
                if (target != this->pi.struc_tab.end())
                {
                    if (!f.name.empty())
                        of << ident_str << "lua_newtable(L);\n";

                    for (auto iter = target->second.fields.begin(); iter != target->second.fields.end(); ++iter)
                    {
                        host2lua(of, target->second, *iter, prefix + f.name + ".", ctx, deep);
                    }

                    if (!f.name.empty())
                        of << ident_str << "lua_setfield(L, -2, \"" << f.name << "\"); \n";
                }
                else
                {
                    std::cerr << "generate code failed, the type: " << f.type << " is not defined yet!\n";
                    std::cin.get();
                    exit(-1);
                }
            }
        }
        else
        { // TODO: to implement
            std::string length_symbol;
            std::string num_of_cpy;
            std::string loop_condition;
            std::string length_specifier_type;
            _Get_length_corresponds(ti, f, length_symbol, num_of_cpy, loop_condition, length_specifier_type, prefix);

            if (is_variable_pointer(f))
            {
                of << ident_str << "if(" << length_symbol << " != 0) ";
                of << "assert(" << prefix << f.name << "!= nullptr);\n";
            }

            std::string varname_vecsize = f.name + "_size";
            /*		if (is_stl_vector(f)) {
            of << ident_str << "uint16_t " << varname_vecsize << "; \n"
            << ident_str << "ibs.read_i(" << varname_vecsize << ");\n";
            }*/
            /*if (is_stl_vector(f))
            {

            }
            */
            if (!num_of_cpy.empty())
            {
                of << ident_str << "obs.write_v(\"" << get_field_name(f) << "\"," << prefix << get_field_name(f) << ", " << num_of_cpy << ");\n";
            }
            else {
                if (is_stl_vector(f)) {

                    of << ident_str << "auto " << varname_vecsize << " = static_cast<uint16_t>(" << prefix << f.name << ".size());\n";
                    //  of << ident_str << "obs.write_i(" << varname_vecsize << ");\n";
                    of << ident_str << "lua_createtable(L, " << varname_vecsize << ", 0);\n";
                    std::string index_var_name = get_array_field_trim_name(f.name) + "index";

                    loop_condition.append(varname_vecsize);

                    of << ident_str << "for(uint16_t " << index_var_name << " = 0; " << loop_condition << "; ++" << index_var_name << ")\n";
                    of << ident_str << "{\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;

                    std::string::size_type pos = f.name.find_first_of('[');
                    new_prefix = prefix + (f.name.substr(0, pos) + "[" + index_var_name + "]");

                    // parse item type
                    pos = f.type.find_first_of('<');
                    temp.type = f.type.substr(pos + 1, f.type.find_first_of('>') - pos - 1);

                    ctx.prefix = new_prefix;
                    ctx.arrayIndex = index_var_name;

                    if (!is_basic_type(temp.type)) {
                        of << ident_str << "    lua_newtable(L);\n";
                    }

                    host2lua(of, ti, temp, new_prefix, ctx, deep + 1);

                    if (!is_basic_type(temp.type)) {
                        of << ident_str << "    lua_rawseti(L, -2, " << index_var_name << " + 1);\n";
                    }

                    of << ident_str << "}\n"
                        << ident_str << "lua_setfield(L, -2, \"" << f.name << "\"); \n";
                }
                else { // maybe never go  here.
                    assert(false);
                    std::string index_var_name = get_array_field_trim_name(f.name) + "index";
                    of << ident_str << "for(" << length_specifier_type << " " << index_var_name << " = 0; " << loop_condition << "; ++" << index_var_name << ")\n";
                    of << ident_str << "{\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;
                    if (is_variable_pointer(f))
                    {
                        new_prefix = prefix + f.name + "[" + index_var_name + "]";
                        temp.type.pop_back();
                    }
                    else
                    {
                        std::string::size_type pos = f.name.find_first_of('[');
                        new_prefix = prefix + (f.name.substr(0, pos) + "[" + index_var_name + "]");
                    }
                    _To_netval(of, ti, temp, new_prefix, deep + 1);
                    of << ident_str << "}\n";
                }
            }
        }
        --deep;
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident(deep) << "}\n";
        }
    }

    void _Append_string(std::ostream & of, const typeinfo & ti, const field & f, const std::string & prefix, int deep = 1)
    {
        std::string ident_str = ident(deep);

        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident_str << "if(" << f.present_condition << ")\n";
            of << ident_str << "{\n";
            ident_str = ident(++deep);
        }

        if (is_single_type_of_field(f))
        {
            if (is_basic_type(f.type))
            {
                if (is_oneb_type(f.type))
                {
                    of << ident_str << "ss << strfmt(\"" << f.name << "\", (int)" << prefix << f.name << " << '\\n', '-');\n";
                }
                else
                {
                    if (!is_fixed_array_type(f.name)) {
                        of << ident_str << "ss << strfmt(\"" << f.name << "\", " << prefix << f.name << " << '\\n', '-');\n";
                    }
                    else {
                        of << ident_str << "ss << strnfmt(\"" << f.name << "\", " << prefix << f.name << "sizeof " << f.name << ", '-');\n";
                    }
                }
            }
            else if (is_string_type(f.type)) {
                of << ident_str << "ss << strfmt(\"" << f.name << "\", " << prefix << f.name << " << '\\n', '-');\n";
            }
            else
            {
                auto target = this->pi.struc_tab.find(f.type);
                if (target != this->pi.struc_tab.end())
                {
                    for (auto iter = target->second.fields.begin(); iter != target->second.fields.end(); ++iter)
                    {
                        _Append_string(of, target->second, *iter, prefix + f.name + ".", deep);
                    }
                }
                else
                {
                    std::cerr << "generate code failed, the type: " << f.type << " is not defined yet!\n";
                    std::cin.get();
                    exit(-1);
                }
            }
        }
        else
        {
            std::string length_symbol;
            std::string num_of_cpy;
            std::string loop_condition;
            std::string length_specifier_type;
            _Get_length_corresponds(ti, f, length_symbol, num_of_cpy, loop_condition, length_specifier_type, prefix);

            if (is_variable_pointer(f))
            {
                of << ident_str << "if(" << length_symbol << " != 0) ";
                of << "assert(" << prefix << f.name << "!= nullptr);\n";
            }

            if (!num_of_cpy.empty())
            {
                auto fieldName = get_field_name(f);
                of << ident_str << "ss << strnfmt(\"" << fieldName << "\", " << prefix << fieldName << ", sizeof " << fieldName << ", '-');\n";
            }
            else {

                if (is_stl_vector(f)) { // for stl do nothing yet.

                }
                else {
                    std::string index_var_name = get_array_field_trim_name(f.name) + "index";
                    of << ident_str << "for(" << length_specifier_type << " " << index_var_name << " = 0; " << loop_condition << "; ++" << index_var_name << ")\n";
                    of << ident_str << "{\n";

                    of << ident_str << "    ss << \"" << prefix << get_field_name(f) << "[\" << " << index_var_name << " << \"]: \\n\";\n";

                    field temp = f;
                    temp.name.clear();
                    std::string new_prefix;
                    if (is_variable_pointer(f))
                    {
                        new_prefix = prefix + f.name + "[" + index_var_name + "]";
                        temp.type.pop_back();
                    }
                    else
                    {
                        std::streamoff pos = f.name.find_first_of('[');
                        new_prefix = prefix + (f.name.substr(0, pos) + "[" + index_var_name + "]");
                    }
                    _Append_string(of, ti, temp, new_prefix, deep + 1);
                    of << ident_str << "}\n";
                }
            }
        }
        --deep;
        if (!f.present_condition.empty() && 1 == deep)
        {
            of << ident(deep) << "}\n";
        }

    }

    void _Write_start(std::ofstream & f, const char* filename)
    {
        std::string op("_");
        op.append(filename);
        op.append("_H_\n");
        nsc::strtoupper(const_cast<char*>(op.c_str()));
        f << "#ifndef " << op;
        f << "#define " << op << "\n";
    }

    void _Write_end(std::ofstream & f)
    {
        f << "\n#endif\n\n";
    }

    void _Get_length_corresponds(const typeinfo & ti, const field & f, std::string & length_symbol, std::string & num_of_cpy, std::string & loop_condition, std::string & length_specifier_type, const std::string & prefix)
    {
        std::string index_var_name = get_array_field_trim_name(f.name) + "index";
        if (!f.length_specifier.empty()) {
            if (is_exists_field_except(ti, f.length_specifier, f.name, length_specifier_type))
            {
                length_symbol = prefix + f.length_specifier;
            }
            else {
                std::cerr << "generate code failed, invalid length specifier for LIST or ARRAY!\n";
                std::cin.get();
                exit(-1);
            }
        }
        else if (is_variable_pointer(f))
        {
            std::cerr << "generate code failed, missing length specifier when use pointer!\n";
            std::cin.get();
            exit(-1);
        }

        bool is_charstream = is_bytestream(f);
        if (is_fixed_array(f))
        {
            if (f.length_specifier.empty())
            {
                length_specifier_type = "int";
                if (is_charstream)
                {
                    num_of_cpy = get_fixed_array_size(f);
                }
                else {
                    loop_condition = "" + index_var_name + " < " + get_fixed_array_size(f);
                }
            }
            else {
                if (is_charstream)
                {
                    num_of_cpy = length_symbol + " <= " + get_fixed_array_size(f) + " ? " + length_symbol + " : " + get_fixed_array_size(f);
                }
                else {
                    loop_condition = "" + index_var_name + " < " + length_symbol + " && " + index_var_name + " < " + get_fixed_array_size(f);
                }
            }
        }
        else
        {
            if (is_charstream)
            {
                num_of_cpy = length_symbol;
            }
            else
            {
                loop_condition = "" + index_var_name + " < " + length_symbol;
            }
        }
    }

private:
    xmldrv::document config;
    std::ofstream   includes_decl;
    std::ofstream   structures_decl;
    std::ofstream   constants_decl;
    std::ofstream   messages_decl;
    std::ofstream   messages_impl;
    std::ofstream   constants_lua;
    std::ofstream   protocol_decl;
    std::ofstream   protocol_impl;

    std::ofstream   protocol_const_lua;
    std::ofstream   protocol_enc_lua;
    std::ofstream   protocol_dec_lua;
    protocol_info   pi;
};

#if defined( _DEBUG) && _TEST == 1
static const int header_size = sizeof messages::HwpHeader;
#endif

int main(int argc, char** argv)
{
    const char* config_file_name = "protocol.xml";
    if (argc > 1)
    {
        config_file_name = argv[1];
    }
    std::cout << "protocol config file name: " << config_file_name << "\n";
    pcode_autog autog(config_file_name);
    autog.load_config();
    autog.generate_code();
    std::cout << "generate code sucessfully, press 'ENTER' to exit...\n";
    // getchar();
    return 0;
};

